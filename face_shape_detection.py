# -*- coding: utf-8 -*-
"""face shape detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EvYEoqdI1ul6iBxZozbPDwcLQ-pbX2j5
"""

import cv2
import dlib
import os
import bz2
import shutil
import requests

# Load the pre-trained models for face and shape prediction
face_detector = dlib.get_frontal_face_detector()

# Specify the path to the model file
model_path = "/content/shape_predictor_68_face_landmarks.dat"

# Download the model file if it doesn't exist
if not os.path.exists(model_path):
    url = "http://dlib.net/files/shape_predictor_68_face_landmarks.dat.bz2"
    print(f"Downloading model from {url}...")
    response = requests.get(url, stream=True)
    response.raise_for_status()
    with open(model_path + ".bz2", 'wb') as f:
        for chunk in response.iter_content(chunk_size=8192):
            f.write(chunk)
    print("Download complete!")

    # Extract the model file
    print("Extracting model...")
    with bz2.BZ2File(model_path + ".bz2", 'rb') as file:
        with open(model_path, 'wb') as uncompressed:
            shutil.copyfileobj(file, uncompressed)
    print("Extraction complete!")
    os.remove(model_path + ".bz2")  # Remove the compressed file


# Load the shape predictor
try:
    shape_predictor = dlib.shape_predictor(model_path)
    print("Model loaded successfully!")
except RuntimeError as e:
    print(f"Error loading model: {e}")
    print("Please ensure the model file is not corrupted "
          "and is compatible with your dlib version.")
    # You might want to exit or handle the error in another way

#

import os
print(os.path.exists("/content/shape_predictor_68_face_landmarks.dat"))

import os
print(os.getcwd())  # Prints the current working directory

import cv2
import dlib
import os

# Load the pre-trained models for face and shape prediction
face_detector = dlib.get_frontal_face_detector()

# Specify the path to the model file
model_path = "/content/shape_predictor_68_face_landmarks.dat"

import bz2
import shutil
import dlib
import requests  # Import requests for downloading

# Step 1: Decompress the .bz2 file (with download check and error handling)
compressed_file = "/content/shape_predictor_68_face_landmarks.dat.bz2"
uncompressed_file = "/content/shape_predictor_68_face_landmarks.dat"

# Download the file if it doesn't exist or is corrupted
if not os.path.exists(compressed_file) or os.path.getsize(compressed_file) == 0:
    url = "http://dlib.net/files/shape_predictor_68_face_landmarks.dat.bz2"  # Replace with actual URL if different
    print(f"Downloading model from {url}...")
    response = requests.get(url, stream=True)
    response.raise_for_status()  # Raise an exception for bad responses
    with open(compressed_file, 'wb') as f:
        for chunk in response.iter_content(chunk_size=8192):
            f.write(chunk)
    print("Download complete!")

try:
    with bz2.BZ2File(compressed_file, 'rb') as file:
        with open(uncompressed_file, 'wb') as uncompressed:
            shutil.copyfileobj(file, uncompressed)
    print("Decompression complete!")
except EOFError:
    print("Error: Compressed file is corrupted. Please re-download it.")
    # You might want to delete the corrupted file here:
    # os.remove(compressed_file)
    # and exit the script or handle the error in another way

import dlib

model_path = "/content/shape_predictor_68_face_landmarks.dat"

try:
    shape_predictor = dlib.shape_predictor(model_path)
    print("Model loaded successfully!")
except RuntimeError as e:
    print(f"Error loading model: {e}")

import dlib
import cv2
import os

# Paths
model_path = "/content/shape_predictor_68_face_landmarks.dat"
image_path = "/content/photo of me.png"

# Load the model
try:
    shape_predictor = dlib.shape_predictor(model_path)
    print("Model loaded successfully!")
except RuntimeError as e:
    print(f"Error loading model: {e}")
    exit()

# Check and load the image
if not os.path.exists(image_path):
    print("Image not found. Please check the path.")
else:
    image = cv2.imread(image_path)
    if image is None:
        print("Failed to load image. File might be corrupted.")
    else:
        print("Image loaded successfully!")

# prompt: show me the image

import cv2
from google.colab.patches import cv2_imshow # Use cv2_imshow for displaying in Colab

# Paths
model_path = "/content/shape_predictor_68_face_landmarks.dat"
image_path = "/content/photo of me.png"

# Load the model (assuming it's already downloaded and decompressed)
try:
    shape_predictor = dlib.shape_predictor(model_path)
    print("Model loaded successfully!")
except RuntimeError as e:
    print(f"Error loading model: {e}")
    exit()

# Check and load the image
if not os.path.exists(image_path):
    print("Image not found. Please check the path.")
else:
    image = cv2.imread(image_path)
    if image is None:
        print("Failed to load image. File might be corrupted.")
    else:
        print("Image loaded successfully!")
        # Detect faces and landmarks (code from the previous responses)
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        faces = face_detector(gray)

        for face in faces:
            landmarks = shape_predictor(gray, face)
            for n in range(68):
                x = landmarks.part(n).x
                y = landmarks.part(n).y
                cv2.circle(image, (x, y), 2, (0, 255, 0), -1)

        # Display the image with landmarks in Colab
        cv2_imshow(image)

# Function to detect facial features
def detect_facial_features(image_path):
    # Load the image
    img = cv2.imread(image_path)
    if img is None:
        print("Image not found. Please check the path.")
        return

    # Convert to grayscale
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # Detect faces in the image
    faces = face_detector(gray)

    for face in faces:
        # Get landmarks for the face
        landmarks = shape_predictor(gray, face)

        # Draw landmarks on the face
        for n in range(68):  # dlib's 68 landmarks
            x = landmarks.part(n).x
            y = landmarks.part(n).y
            cv2.circle(img, (x, y), 2, (0, 255, 0), -1)

import dlib
import cv2
import os

# Load the model (ensure this part is executed)
try:
    shape_predictor = dlib.shape_predictor("/content/shape_predictor_68_face_landmarks.dat")  # Or your model path
    face_detector = dlib.get_frontal_face_detector() # Get the face detector
    print("Model loaded successfully!")
except RuntimeError as e:
    print(f"Error loading model: {e}")
    exit()

# Paths
image_path = "/content/photo of me.png"

# Function to detect facial features
def detect_facial_features(image_path):
    # Load the image
    # If image_path is a string, load from file
    if isinstance(image_path, str):
        img = cv2.imread(image_path)
        if img is None:
            print("Image not found. Please check the path.")
            return None  # Explicitly return None if image loading fails
    # If image_path is already an image (numpy array), use it directly
    else:
        img = image_path

    # Convert to grayscale
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # Detect faces in the image
    faces = face_detector(gray)

    for face in faces:
        # Get landmarks for the face
        landmarks = shape_predictor(gray, face)

        # Draw landmarks on the face
        for n in range(68):  # dlib's 68 landmarks
            x = landmarks.part(n).x
            y = landmarks.part(n).y
            cv2.circle(img, (x, y), 2, (0, 255, 0), -1)

    return img # Return the modified image

# Detect and display facial features
image_with_landmarks = detect_facial_features(image_path)  # Pass the path directly
# Check if image_with_landmarks is not None before displaying
if image_with_landmarks is not None:
  cv2_imshow(image_with_landmarks)

#Detect and display facial features
image_with_landmarks = detect_facial_features(image.copy()) # Create a copy to avoid modifying original image.
# Check if image_with_landmarks is not None before displaying
if image_with_landmarks is not None:
  cv2_imshow(image_with_landmarks)

# Usage: Provide the path to your image
detect_facial_features("/content/photo of me.png")

import cv2
import dlib
import numpy as np

# Load Dlib's face detector and landmark predictor
detector = dlib.get_frontal_face_detector()
predictor = dlib.shape_predictor("shape_predictor_68_face_landmarks.dat")

def extract_landmarks(image):
    """
    Extract facial landmarks using Dlib.
    """
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    faces = detector(gray)
    if len(faces) == 0:
        print("No faces detected.")
        return None

    landmarks = []
    for face in faces:
        shape = predictor(gray, face)
        landmarks.append([(point.x, point.y) for point in shape.parts()])
    return landmarks

def calculate_ratios_and_distances(landmarks):
    """
    Calculate facial ratios and distances to determine shape.
    """
    # Example: Calculate jawline length, cheekbone width, and face length
    jawline = landmarks[0:17]  # Points 0 to 16
    cheekbones = landmarks[1:17:4]  # Approximate cheekbone region
    forehead_to_chin = (landmarks[8], landmarks[27])  # Chin to forehead midline

    # Calculate distances
    jawline_length = np.linalg.norm(np.array(jawline[-1]) - np.array(jawline[0]))
    cheekbone_width = np.linalg.norm(np.array(cheekbones[0]) - np.array(cheekbones[-1]))
    face_length = np.linalg.norm(np.array(forehead_to_chin[0]) - np.array(forehead_to_chin[1]))

    # Calculate ratios
    ratio_width_to_length = cheekbone_width / face_length
    ratio_jaw_to_length = jawline_length / face_length

    return ratio_width_to_length, ratio_jaw_to_length

def classify_facial_shape(ratio_width_to_length, ratio_jaw_to_length):
    """
    Classify the facial shape based on calculated ratios.
    """
    if ratio_width_to_length < 0.8 and ratio_jaw_to_length < 0.6:
        return "Oval"
    elif 0.8 <= ratio_width_to_length <= 1.0 and ratio_jaw_to_length >= 0.6:
        return "Round"
    elif ratio_width_to_length > 1.0:
        return "Square"
    else:
        return "Unknown"

def main(image_path):
    """
    Main function to process the image and determine the facial shape.
    """
    image = cv2.imread(image_path)
    if image is None:
        print("Failed to load image.")
        return

    landmarks = extract_landmarks(image)
    if not landmarks:
        return

    for face_landmarks in landmarks:
        ratio_width_to_length, ratio_jaw_to_length = calculate_ratios_and_distances(face_landmarks)
        facial_shape = classify_facial_shape(ratio_width_to_length, ratio_jaw_to_length)
        print(f"Detected facial shape: {facial_shape}")

if __name__ == "__main__":
    image_path = "/content/photo of me.png"  # Replace with the path to your image
    main(image_path)